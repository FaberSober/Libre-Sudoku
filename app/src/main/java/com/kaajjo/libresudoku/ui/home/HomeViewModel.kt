package com.kaajjo.libresudoku.ui.home

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kaajjo.libresudoku.core.Cell
import com.kaajjo.libresudoku.core.qqwing.GameDifficulty
import com.kaajjo.libresudoku.core.qqwing.GameType
import com.kaajjo.libresudoku.core.qqwing.QQWingController
import com.kaajjo.libresudoku.core.utils.SudokuParser
import com.kaajjo.libresudoku.data.database.model.SudokuBoard
import com.kaajjo.libresudoku.domain.repository.BoardRepository
import com.kaajjo.libresudoku.domain.repository.SavedGameRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class HomeViewModel
@Inject constructor(
    private val boardRepository: BoardRepository,
    private val savedGameRepository: SavedGameRepository
) : ViewModel() {
    // TODO REFACTOR
    var showContinueGameDialog by mutableStateOf(false)

    private var intPuzzle: IntArray = IntArray(81)

    val lastSaved = savedGameRepository.getLast()
    private val lastSavedValue = lastSaved.stateIn(viewModelScope, SharingStarted.Eagerly, null)
    private var board: MutableList<Int> = mutableListOf()
    private var solvedBoard: MutableList<Int> = mutableListOf()
    var insertedBoardUid = 1L

    var isGenerating by mutableStateOf(false)
    var generated by mutableStateOf(false)
    var isSolving by mutableStateOf(false)
    var solved by mutableStateOf(false)
    var puzzle = MutableList(9) { row -> MutableList(9) { col -> Cell(row, col, 0) } }
    var solvedPuzzle = MutableList(9) { row -> MutableList(9) { col -> Cell(row, col, 0) } }

    private val difficulties = listOf(
        GameDifficulty.Easy,
        GameDifficulty.Moderate,
        GameDifficulty.Hard,
        GameDifficulty.Challenge,
    )
    var selectedDifficulty by mutableStateOf(difficulties.first())

    private val types = listOf(
        GameType.Default9x9,
        GameType.Default6x6,
        GameType.Default12x12
    )
    var selectedType by mutableStateOf(types.first())

    fun generate() {
        val size = selectedType.size
        puzzle =
            MutableList(selectedType.size) { row -> MutableList(size) { col -> Cell(row, col, 0) } }

        generated = false
        isGenerating = true
        val thread = Thread {
            val controller = QQWingController()
            intPuzzle = controller.generate(selectedType, selectedDifficulty)
            board = intPuzzle.toMutableList()
            for (i in 0 until size) {
                for (j in 0 until size) {
                    puzzle[i][j].value = intPuzzle[i * size + j]
                }
            }

            isGenerating = false
            generated = true
        }
        thread.start()
    }

    fun solve() {
        isSolving = true
        val size = selectedType.size
        solvedPuzzle =
            MutableList(selectedType.size) { row -> MutableList(size) { col -> Cell(row, col, 0) } }

        val thread = Thread {
            val controller = QQWingController()
            intPuzzle = controller.solve(intPuzzle, selectedType)
            solvedBoard = intPuzzle.toMutableList()
            for (i in 0 until size) {
                for (j in 0 until size) {
                    solvedPuzzle[i][j].value = intPuzzle[i * size + j]
                }
            }
            isSolving = false
            solved = true
        }
        thread.start()
    }

    fun setDifficulty(diff: Int) {
        val indexToSet = difficulties.indexOf(selectedDifficulty) + diff
        if (indexToSet >= 0 && indexToSet < difficulties.count()) {
            selectedDifficulty = difficulties[indexToSet]
        }
    }

    fun setType(diff: Int) {
        val indexToSet = types.indexOf(selectedType) + diff
        if (indexToSet >= 0 && indexToSet < types.count()) {
            selectedType = types[indexToSet]
        }
    }

    suspend fun saveToDatabase() {
        val sudokuParser = SudokuParser()
        val newBoard =
            List(selectedType.size) { row -> List(selectedType.size) { col -> Cell(row, col, 0) } }
        val newSolvedBoard =
            List(selectedType.size) { row -> List(selectedType.size) { col -> Cell(row, col, 0) } }
        for (i in 0 until selectedType.size) {
            for (j in 0 until selectedType.size) {
                newBoard[i][j].value = board[j + selectedType.size * i]
                newSolvedBoard[i][j].value = solvedBoard[j + selectedType.size * i]
            }
        }
        insertedBoardUid = boardRepository.insert(
            SudokuBoard(
                uid = 0,
                initialBoard = sudokuParser.boardToString(newBoard),
                solvedBoard = sudokuParser.boardToString(newSolvedBoard),
                difficulty = selectedDifficulty,
                type = selectedType
            )
        )
    }

    fun giveUpLastGame() {
        viewModelScope.launch(Dispatchers.IO) {
            lastSavedValue.value?.let {
                if (!it.completed) {
                    savedGameRepository.update(
                        it.copy(
                            completed = true,
                            canContinue = true
                        )
                    )
                }
            }
        }
    }
}